Чтобы написать GUI-программу надо выполнить приблизительно следующее:

1. Создать главное окно.
2. Создать виджеты и выполнить конфигурацию их свойств.
3. Определить события, на которые будет реагировать программа.
4. Определить обработчики собыйтий, т.е. как будет реагировать программа.
5. Расположить виджеты в главном окне.
6. Запустить цикл обработки событий.

Виджетами явл-ся все элементы интерфейса (окна, кнопки, флажки, скроллеры и др.)

В современных ОС любое пользовательское приложение 
заключается в окно, которое можно назвать главным, т.к.
в нем рвсполагаются все остальные виджеты.
Объект верхнего уровня создается от класса Tk.
Переменную, связываемую с объектом, часто наз-ют root.

root = Tk()

Пусть в окне приложения располагаются текстовое поле (entry),
метка (label) и кнопка(button). Данные обьекты создаются от соотв.
класса модуля tkinter.

e = Entry(root, width=20)
b = Button(root, text="ПРеобразовать")
l = Label(root, bg='black', fg='white', width=20)

Обратим внимание, что первым аргументом указ-ся 'хоязяин, мастер'
 - место, где располагается виджет. Виджеты не обязательно
 располагаются на root'е. Они могут размещаться в других виджетах.
 
Пусть в программе текст, введенный в поле, при нажатии на кнопку
разбивается на список слов, слова сортируются по алфавиту и выводятся в метке.
Код выполняющий все это надо поместить в функцию:

def strToSortList(event):
	s = e.get()
	s = s.split()
	s.sort()
	l['text'] = ' '.join(s)
	
У функций, которые выз-ся при наступлении события с  помощью
метода bind() должен быть один параметр. Обычно его наз-ют event(события).

Теперь надо свзяать вызов функции с событием:
b.bind('Button-1', strToSortList)

В данном случае это делается с помощью метода bind().
Ему передается событие и вызываемая функция.
В данном случае событием явл-ся целчок левой кнопкой мыши.

В любом приложении виджеты не разбросаны по окну как попало.
Пока расположим элементы друг за другом с помощью наиболее
простого менеджера геометрии - метода pack():

e.pack()
b.pack()
l.pack()

Метод mainloop() объекта Tk запускает главный цикл обработки
событий, в т.ч. приводит к отображению главнго окна со всеми
его причиндалами на экране:
root.mainloop()

===Полный код программы===:

from tkinter import *
 
root = Tk()
 
e = Entry(width=20)
b = Button(text="Преобразовать")
l = Label(bg='black', fg='white', width=20)
 
def strToSortlist(event):
    s = e.get()
    s = s.split()
    s.sort()
    l['text'] = ' '.join(s)
 
b.bind('<Button-1>', strToSortlist)
 
e.pack()
b.pack()
l.pack()
root.mainloop()
=============================

Реализуем объектно-ориентированный подход.
Пусть комплект из метки, кнопки и поля представляет собой один
один объект, порождаемый от некого класса Block.
Тогда в основной ветке программы будет главное окно, объект типа Block и
запуск окна. Поскольку блок должен быть привязан к главному окну, то
передадим в конструктор класса Block окно-родитель root:

from tkinter import *
 
root = Tk()
 
first_block = Block(root)
 
root.mainloop()


Теперь напишем сам класс Block:
class Block:
    def __init__(self, master):
        self.e = Entry(master, width=20)
        self.b = Button(master, text="Преобразовать")
        self.l = Label(master, bg='black', fg='white', width=20)
        self.b['command'] = self.strToSortlist
        self.e.pack()
        self.b.pack()
        self.l.pack()	
    def strToSortlist(self):
        s = self.e.get()
        s = s.split()
        s.sort()
        self.l['text'] = ' '.join(s)

Здесь виджеты явл-ся значениями полей типа Block, функция-обработчик 
события нажатия на кнопку устанавливается не с помощью мтода bind(),
а с помощью свойства кнопки 'command'. В этом случае не требуется
параметр event.
Однако если код будет выглядеть так, то необходимости в классе нет.
Смысл появится, если нам потребуется несколько обьектов-блоков.
Допустим, нам нужно несколько блоков, состоящих из метки, кнопки и поля.
Причем у кнопки каждой группы будет своя функция-обработчик клика.

Тогда можно вынести установку значения для свойств command
в отдельный метод, куда передавать и функцию-обработчик события.
Полный код программы:

from tkinter import *
 
class Block:
    def __init__(self, master):
        self.e = Entry(master, width=20)
        self.b = Button(master, text="Преобразовать")
        self.l = Label(master, bg='black', fg='white', width=20)
        self.e.pack()
        self.b.pack()
        self.l.pack()
    def setFunc(self, func):
        self.b['command'] = eval('self.' + func)	
	def strToSortlist(self):
        s = self.e.get()
        s = s.split()
        s.sort()
        self.l['text'] = ' '.join(s)
    def strReverse(self):
        s = self.e.get()
        s = s.split()
        s.reverse()
        self.l['text'] = ' '.join(s)
		
root = Tk()
 
first_block = Block(root)
first_block.setFunc('strToSortlist')
 
second_block = Block(root)
second_block.setFunc('strReverse')
 
root.mainloop()
================================
При выполнении этого кода в окне будут выведены два однотипных
блока,кнопки которых выполняют разные действия.
Класс можно сделать более гибким, если жестко не задавать 
свойства виджетов, а передавать значения как аргументы в конструктор,
после чего присваивать их соотв.свойствам при создании объектов.


